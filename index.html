<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>P-WORLD 機種抽出 OCRツール</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- pdf.js & Tesseract.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    body { font-family: sans-serif; margin: 20px; }
    section { margin-bottom: 20px; }
    table { border-collapse: collapse; width: 100%; margin-top: 10px; }
    th, td { border: 1px solid #999; padding: 4px; font-size: 14px; }
    th { background: #eee; }
    .btn { margin: 5px; padding: 6px 12px; }
    #progress { margin-top: 10px; color: blue; }
  </style>
</head>
<body>
  <main>
    <h2>P-WORLD 機種抽出（画像/PDF → OCR → CSV/XLSX）</h2>

    <section>
      <label>店舗名: <input type="text" id="store" value="コトブキプラス鹿浜店"></label>
      <label>店グループ: <input type="text" id="group" value="自店"></label>
      <label>取得日: <input type="date" id="capture-date"></label>
    </section>

    <section>
      <p>画像またはPDFをアップロードしてください:</p>
      <input type="file" id="fileInput" multiple>
      <p>マスターCSV（任意）:</p>
      <input type="file" id="masterInput" accept=".csv">
    </section>

    <section>
      <button id="runBtn" class="btn">OCR 実行</button>
      <button id="dlCsvBtn" class="btn" disabled>CSV ダウンロード</button>
      <button id="dlXlsxBtn" class="btn" disabled>Excel(xlsx) ダウンロード</button>
    </section>

    <section id="progress">待機中...</section>

    <section class="tablewrap">
      <table id="resultTable">
        <thead>
          <tr>
            <th>#</th>
            <th>raw (OCR)</th>
            <th>normalized (整形)</th>
            <th>matched_master</th>
            <th>score</th>
            <th>method</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </main>

  <footer>
    <p class="small">※ アップロードされた画像/PDFはサーバへ送信されず、ブラウザ内のみで処理されます。</p>
  </footer>

  <!-- ====== OCRスクリプト本体 ====== -->
  <script>
  if (window.pdfjsLib) {
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.8.69/pdf.worker.min.js';
  }

  async function pdfToImages(file) {
    const arrBuf = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrBuf }).promise;
    const imgs = [];
    for (let p = 1; p <= pdf.numPages; p++) {
      const page = await pdf.getPage(p);
      const viewport = page.getViewport({ scale: 2.0 });
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({ canvasContext: ctx, viewport }).promise;
      const blob = await new Promise(res => canvas.toBlob(res, 'image/png', 0.95));
      imgs.push(new File([blob], `page_${p}.png`, { type: 'image/png' }));
    }
    return imgs;
  }

  function normalizeName(s) {
    if (!s) return "";
    const map = { "Ａ":"A","Ｂ":"B","Ｃ":"C","Ｄ":"D","Ｅ":"E","Ｆ":"F","Ｇ":"G","Ｈ":"H","Ｉ":"I","Ｊ":"J","Ｋ":"K","Ｌ":"L","Ｍ":"M","Ｎ":"N","Ｏ":"O","Ｐ":"P","Ｑ":"Q","Ｒ":"R","Ｓ":"S","Ｔ":"T","Ｕ":"U","Ｖ":"V","Ｗ":"W","Ｘ":"X","Ｙ":"Y","Ｚ":"Z",
      "ａ":"a","ｂ":"b","ｃ":"c","ｄ":"d","ｅ":"e","ｆ":"f","ｇ":"g","ｈ":"h","ｉ":"i","ｊ":"j","ｋ":"k","ｌ":"l","ｍ":"m","ｎ":"n","ｏ":"o","ｐ":"p","ｑ":"q","ｒ":"r","ｓ":"s","ｔ":"t","ｕ":"u","ｖ":"v","ｗ":"w","ｘ":"x","ｙ":"y","ｚ":"z",
      "０":"0","１":"1","２":"2","３":"3","４":"4","５":"5","６":"6","７":"7","８":"8","９":"9",
      "－":"-","ー":"-","―":"-","‐":"-","ｰ":"-","　":" " };
    s = s.replace(/./g, ch => map[ch] ?? ch).replace(/\s+/g, " ").trim();
    return s;
  }

  function parseMasterCsv(text) {
    const rows = text.split(/\r?\n/).map(l => l.split(",").map(s => s.trim())).filter(r => r.length && r[0]);
    const map = new Map();
    for (const r of rows) {
      const canonical = normalizeName(r[0]);
      if (!map.has(canonical)) map.set(canonical, new Set([canonical]));
      for (let i = 1; i < r.length; i++) {
        const alias = normalizeName(r[i]); if (alias) map.get(canonical).add(alias);
      }
    }
    return map;
  }

  function matchToMaster(items, masterMap) {
    if (!masterMap) return items.map(it => ({ ...it, matched_master: "", score: "" }));
    const out = [];
    for (const it of items) {
      let best=null, bestScore=0;
      for (const [canon, aliases] of masterMap.entries()) {
        for (const alias of aliases) {
          let score=0;
          if (it.normalized === alias) score=1;
          else if (it.normalized.includes(alias) || alias.includes(it.normalized)) score=0.7;
          if (score > bestScore) { bestScore=score; best=canon; }
        }
      }
      out.push({ ...it, matched_master: best ?? "", score: best ? bestScore.toFixed(2) : "" });
    }
    return out;
  }

  async function runOCR_onFiles(files, { lang="jpn+eng", psm=6 } = {}) {
    const { createWorker } = Tesseract;
    const worker = await createWorker({ logger: m => console.log(m) });
    await worker.loadLanguage(lang); await worker.initialize(lang);
    await worker.setParameters({ tessedit_pageseg_mode: String(psm) });

    const results = [];
    for (const f of files) {
      const { data } = await worker.recognize(f);
      const lines = (data.text||"").split(/\r?\n/).map(v=>v.trim()).filter(Boolean);
      for (const ln of lines) if (ln.length>=3) results.push({ raw: ln, normalized: normalizeName(ln) });
    }
    await worker.terminate();
    return results;
  }

  const btnRun = document.getElementById('runBtn');
  const btnCsv = document.getElementById('dlCsvBtn');
  const btnXlsx = document.getElementById('dlXlsxBtn');
  const tbody = document.querySelector("#resultTable tbody");
  const progressEl = document.getElementById('progress');
  let rows = [];

  function renderRows(rs) {
    tbody.innerHTML="";
    rs.forEach((r,i)=>{
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${i+1}</td><td>${r.raw}</td><td>${r.normalized}</td><td>${r.matched_master||""}</td><td>${r.score||""}</td><td>tesseract</td>`;
      tbody.appendChild(tr);
    });
  }

  function toCSV(rs){
    const header=["date","store","group","raw","normalized","matched_master","score","method"];
    const lines=[header.join(",")].concat(rs.map(r=>header.map(h=>r[h]??"").join(",")));
    return lines.join("\r\n");
  }
  function download(filename, blob){
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download=filename; a.click(); URL.revokeObjectURL(a.href);
  }

  btnRun.addEventListener('click', async ()=>{
    try{
      const fileInput=document.getElementById('fileInput');
      if(!fileInput.files.length){ alert("ファイルを選択してください"); return; }
      let images=[];
      for(const f of fileInput.files){
        if(f.type==="application/pdf"||f.name.toLowerCase().endsWith(".pdf")){
          const pages=await pdfToImages(f); images.push(...pages);
        } else images.push(f);
      }
      progressEl.textContent="OCR実行中...";
      const ocrItems=await runOCR_onFiles(images);

      let masterMap=null;
      const mInput=document.getElementById('masterInput');
      if(mInput.files.length){
        const text=await mInput.files[0].text();
        masterMap=parseMasterCsv(text);
      }
      const store=document.getElementById('store').value;
      const group=document.getElementById('group').value;
      const ymd=document.getElementById('capture-date').value;

      const matched=matchToMaster(ocrItems, masterMap);
      rows = matched.map(r=>({date:ymd,store,group,raw:r.raw,normalized:r.normalized,
        matched_master:r.matched_master,score:r.score,method:"tesseract"}));
      renderRows(matched);
      progressEl.textContent=`抽出：${rows.length}件`;

      btnCsv.disabled=rows.length===0;
      btnXlsx.disabled=rows.length===0;
    }catch(e){ console.error(e); progressEl.textContent="エラー"; alert("OCR中にエラー"); }
  });

  btnCsv.addEventListener('click', ()=>{
    const csv=toCSV(rows);
    download(`ocr_${Date.now()}.csv`, new Blob([csv],{type:'text/csv'}));
  });
  btnXlsx.addEventListener('click', ()=>{
    const csv=toCSV(rows);
    download(`ocr_${Date.now()}.xlsx.csv`, new Blob([csv],{type:'text/csv'}));
  });
  </script>
  <!-- Tesseract.js 本体は defer で先に読み込ませる（順序重要） -->
<script defer src="https://unpkg.com/tesseract.js@5.1.0/dist/tesseract.min.js"></script>

<script defer>
(() => {
  // ====== DOM取得（あなたのID名に合わせて必要なら変更） ======
  const $ = s => document.querySelector(s);
  const fileInput = $('#imageInput');       // 画像/PDFの <input type="file"> のID
  const runBtn    = $('#btnRunOCR');        // 「OCR実行」ボタンのID
  const progBar   = $('#progress');         // <progress> か 数値表示用 <span>
  const progText  = $('#progressText');     // 進捗%を出す <span>
  const statusEl  = $('#statusText');       // 「OCR実行中…」などのステータス表示
  const tbody     = $('#resultBody');       // 結果テーブルの <tbody>

  // ====== 進捗表示の初期化 ======
  function resetUI(msg='') {
    if (progBar)  progBar.value = 0;
    if (progText) progText.textContent = '0%';
    if (statusEl) statusEl.textContent = msg;
    if (tbody)    tbody.innerHTML = '';
  }

  // ====== Tesseract パス（絶対URL固定） ======
  const PATHS_PRIMARY = {
    workerPath: 'https://unpkg.com/tesseract.js-core@5.0.2/worker.min.js',
    corePath:   'https://unpkg.com/tesseract.js-core@5.0.2/tesseract-core.wasm.js',
    langPath:   'https://tessdata.projectnaptha.com/5', // jpn/eng の学習データ置き場
  };
  const PATHS_FALLBACK = {
    workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.2/worker.min.js',
    corePath:   'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.0.2/tesseract-core.wasm.js',
    langPath:   'https://tessdata.projectnaptha.com/5',
  };

  // ====== 画像 → OCR 実行 ======
  async function ocrImageBlob(blob) {
    // ログをコンソールへ（進捗％を拾うため必須）
    Tesseract.setLogging(true);

    let lastErr;
    for (const PATHS of [PATHS_PRIMARY, PATHS_FALLBACK]) {
      try {
        const worker = await Tesseract.createWorker({
          workerPath: PATHS.workerPath,
          corePath:   PATHS.corePath,
          langPath:   PATHS.langPath,
          logger: m => {
            if (m.status && statusEl) statusEl.textContent = m.status;
            if (typeof m.progress === 'number') {
              if (progBar)  progBar.value = m.progress;
              if (progText) progText.textContent = Math.round(m.progress * 100) + '%';
            }
            // デバッグは必要に応じて
            // console.log(m);
          }
        });

        await worker.loadLanguage('jpn+eng');
        await worker.initialize('jpn+eng');

        // 画像の自動回転もON
        const { data } = await worker.recognize(blob, { rotateAuto: true });
        await worker.terminate();
        return data.text || '';
      } catch (e) {
        lastErr = e;
        // 次のCDNへフォールバック
      }
    }
    throw lastErr || new Error('OCR初期化に失敗しました');
  }

  // ====== 画像/PDF -> 画像化（PDF対応していないなら画像のみでOK） ======
  async function fileToImageBlob(file) {
    // 画像ならそのまま
    if (/^image\//.test(file.type)) {
      return file;
    }
    // PDF対応を入れていない場合はここで弾く
    throw new Error('PDFは未対応です。画像（PNG/JPG）を選択してください。');
  }

  // ====== 結果をテーブルへ反映（最低限・rawのみ） ======
  function renderResultLines(text) {
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    if (!tbody) return;
    tbody.innerHTML = '';
    lines.forEach((line, i) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${i+1}</td>
        <td>${escapeHtml(line)}</td>
        <td></td><td></td><td></td><td></td>
      `;
      tbody.appendChild(tr);
    });
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // ====== ボタン活性制御 ======
  function updateRunButton() {
    runBtn && (runBtn.disabled = !fileInput || !fileInput.files || fileInput.files.length === 0);
  }

  fileInput && fileInput.addEventListener('change', () => {
    resetUI('');
    updateRunButton();
  });

  runBtn && runBtn.addEventListener('click', async () => {
    updateRunButton();
    resetUI('準備中…');

    const f = fileInput?.files?.[0];
    if (!f) { statusEl && (statusEl.textContent = 'ファイルが選択されていません'); return; }

    runBtn.disabled = true;

    // 60秒ウォッチドッグ（何も進まない時の気づき用）
    let watchdog = setTimeout(() => {
      if (statusEl && (!progBar || progBar.value === 0)) {
        statusEl.textContent = '読み込みが進みません。ネットワーク/社内フィルタでCDNがブロックされている可能性があります（unpkg→jsDelivrへの自動切替済）。';
      }
    }, 60000);

    try {
      statusEl && (statusEl.textContent = '画像準備中…');
      const blob = await fileToImageBlob(f);

      statusEl && (statusEl.textContent = 'OCR実行中…');
      const text  = await ocrImageBlob(blob);

      statusEl && (statusEl.textContent = '完了');
      renderResultLines(text || '(テキストなし)');
    } catch (err) {
      console.error(err);
      statusEl && (statusEl.textContent = 'エラー');
      if (tbody) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="6" style="color:#c00;">${escapeHtml(String(err?.message || err))}</td>`;
        tbody.appendChild(tr);
      }
    } finally {
      clearTimeout(watchdog);
      runBtn.disabled = false;
    }
  });

  // 初期状態
  updateRunButton();
  resetUI('');
})();
</script>

</body>
</html>

